{"version":"blocks-webapp@0.2.0","name":"DIP721 Template","description":"","readme":"","language":"motoko","output":"import Error \"mo:base/Error\";\nimport Hash \"mo:base/Hash\";\nimport HashMap \"mo:base/HashMap\";\nimport Nat \"mo:base/Nat\";\nimport Option \"mo:base/Option\";\nimport Principal \"mo:base/Principal\";\nimport Array \"mo:base/Array\";\nimport Iter \"mo:base/Iter\";\nimport P \"mo:base/Prelude\";\n\nactor class Dip721Template(_name : Text, _symbol : Text) {\n\t// Adapted from: https://github.com/SuddenlyHazel/DIP721/blob/main/src/DIP721/DIP721.mo\n\t\n\tprivate type TokenAddress = Principal;\n\tprivate type TokenId = Nat;\n\t\n\tprivate stable var tokenPk : Nat = 0;\n\t\n\tprivate stable var tokenURIEntries : [(TokenId, Text)] = [];\n\tprivate stable var ownersEntries : [(TokenId, Principal)] = [];\n\tprivate stable var balancesEntries : [(Principal, Nat)] = [];\n\tprivate stable var tokenApprovalsEntries : [(TokenId, Principal)] = [];\n\tprivate stable var operatorApprovalsEntries : [(Principal, [Principal])] = [];\n\t\n\tprivate let tokenURIs : HashMap.HashMap<TokenId, Text> = HashMap.fromIter<TokenId, Text>(tokenURIEntries.vals(), 10, Nat.equal, Hash.hash);\n\tprivate let owners : HashMap.HashMap<TokenId, Principal> = HashMap.fromIter<TokenId, Principal>(ownersEntries.vals(), 10, Nat.equal, Hash.hash);\n\tprivate let balances : HashMap.HashMap<Principal, Nat> = HashMap.fromIter<Principal, Nat>(balancesEntries.vals(), 10, Principal.equal, Principal.hash);\n\tprivate let tokenApprovals : HashMap.HashMap<TokenId, Principal> = HashMap.fromIter<TokenId, Principal>(tokenApprovalsEntries.vals(), 10, Nat.equal, Hash.hash);\n\tprivate let operatorApprovals : HashMap.HashMap<Principal, [Principal]> = HashMap.fromIter<Principal, [Principal]>(operatorApprovalsEntries.vals(), 10, Principal.equal, Principal.hash);\n\t\n\tprivate func _unwrap<T>(x : ?T) : T {\n\t\tswitch x {\n\t\t\tcase null { P.unreachable() };\n\t\t\tcase (?x_) { x_ };\n\t\t}\n\t};\n\t\n\tpublic shared query func balanceOf(p : Principal) : async ?Nat {\n\t\treturn balances.get(p);\n\t};\n\t\n\tpublic shared query func ownerOf(tokenId : TokenId) : async ?Principal {\n\t\treturn _ownerOf(tokenId);\n\t};\n\t\n\tpublic shared query func tokenURI(tokenId : TokenId) : async ?Text {\n\t\treturn _tokenURI(tokenId);\n\t};\n\t\n\tpublic shared query func name() : async Text {\n\t\treturn _name;\n\t};\n\t\n\tpublic shared query func symbol() : async Text {\n\t\treturn _symbol;\n\t};\n\t\n\tpublic shared func isApprovedForAll(owner : Principal, opperator : Principal) : async Bool {\n\t\treturn _isApprovedForAll(owner, opperator);\n\t};\n\t\n\tpublic shared(msg) func approve(to : Principal, tokenId : TokenId) : async () {\n\t\tswitch(_ownerOf(tokenId)) {\n\t\t\tcase (?owner) {\n\t\t\t\tassert to != owner;\n\t\t\t\tassert msg.caller == owner or _isApprovedForAll(owner, msg.caller);\n\t\t\t\t_approve(to, tokenId);\n\t\t\t};\n\t\t\tcase (null) {\n\t\t\t\tthrow Error.reject(\"No owner for token\")\n\t\t\t};\n\t\t}\n\t};\n\t\n\tpublic shared func getApproved(tokenId : Nat) : async Principal {\n\t\tswitch(_getApproved(tokenId)) {\n\t\t\tcase (?v) { return v };\n\t\t\tcase null { throw Error.reject(\"None approved\") }\n\t\t}\n\t};\n\t\n\tpublic shared(msg) func setApprovalForAll(op : Principal, isApproved : Bool) : () {\n\t\tassert msg.caller != op;\n\t\t\n\t\tswitch (isApproved) {\n\t\t\tcase true {\n\t\t\t\tswitch (operatorApprovals.get(msg.caller)) {\n\t\t\t\t\tcase (?opList) {\n\t\t\t\t\t\tvar array = Array.filter<Principal>(opList,func (p) { p != op });\n\t\t\t\t\t\tarray := Array.append<Principal>(array, [op]);\n\t\t\t\t\t\toperatorApprovals.put(msg.caller, array);\n\t\t\t\t\t};\n\t\t\t\t\tcase null {\n\t\t\t\t\t\toperatorApprovals.put(msg.caller, [op]);\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t};\n\t\t\tcase false {\n\t\t\t\tswitch (operatorApprovals.get(msg.caller)) {\n\t\t\t\t\tcase (?opList) {\n\t\t\t\t\t\tlet array = Array.filter<Principal>(opList, func(p) { p != op });\n\t\t\t\t\t\toperatorApprovals.put(msg.caller, array);\n\t\t\t\t\t};\n\t\t\t\t\tcase null {\n\t\t\t\t\t\toperatorApprovals.put(msg.caller, []);\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t\t\n\t};\n\t\n\tpublic shared(msg) func transferFrom(from : Principal, to : Principal, tokenId : Nat) : () {\n\t\tassert _isApprovedOrOwner(msg.caller, tokenId);\n\t\t\n\t\t_transfer(from, to, tokenId);\n\t};\n\t\n\tpublic shared(msg) func mint(uri : Text) : async Nat {\n\t\ttokenPk += 1;\n\t\t_mint(msg.caller, tokenPk, uri);\n\t\treturn tokenPk;\n\t};\n\t\n\t\n\t// Internal\n\t\n\tprivate func _ownerOf(tokenId : TokenId) : ?Principal {\n\t\treturn owners.get(tokenId);\n\t};\n\t\n\tprivate func _tokenURI(tokenId : TokenId) : ?Text {\n\t\treturn tokenURIs.get(tokenId);\n\t};\n\t\n\tprivate func _isApprovedForAll(owner : Principal, opperator : Principal) : Bool {\n\t\tswitch (operatorApprovals.get(owner)) {\n\t\t\tcase(?whiteList) {\n\t\t\t\tfor (allow in whiteList.vals()) {\n\t\t\t\t\tif (allow == opperator) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t};\n\t\t\tcase null {return false;};\n\t\t};\n\t\treturn false;\n\t};\n\t\n\tprivate func _approve(to : Principal, tokenId : Nat) : () {\n\t\ttokenApprovals.put(tokenId, to);\n\t};\n\t\n\tprivate func _removeApprove(tokenId : Nat) : () {\n\t\tignore tokenApprovals.remove(tokenId);\n\t};\n\t\n\tprivate func _exists(tokenId : Nat) : Bool {\n\t\treturn Option.isSome(owners.get(tokenId));\n\t};\n\t\n\tprivate func _getApproved(tokenId : Nat) : ?Principal {\n\t\tassert _exists(tokenId) == true;\n\t\tswitch(tokenApprovals.get(tokenId)) {\n\t\t\tcase (?v) { return ?v };\n\t\t\tcase null {\n\t\t\t\treturn null;\n\t\t\t};\n\t\t}\n\t};\n\t\n\tprivate func _hasApprovedAndSame(tokenId : Nat, spender : Principal) : Bool {\n\t\tswitch(_getApproved(tokenId)) {\n\t\t\tcase (?v) {\n\t\t\t\treturn v == spender;\n\t\t\t};\n\t\t\tcase null { return false }\n\t\t}\n\t};\n\t\n\tprivate func _isApprovedOrOwner(spender : Principal, tokenId : Nat) : Bool {\n\t\tassert _exists(tokenId);\n\t\tlet owner = _unwrap(_ownerOf(tokenId));\n\t\treturn spender == owner or _hasApprovedAndSame(tokenId, spender) or _isApprovedForAll(owner, spender);\n\t};\n\t\n\tprivate func _transfer(from : Principal, to : Principal, tokenId : Nat) : () {\n\t\tassert _exists(tokenId);\n\t\tassert _unwrap(_ownerOf(tokenId)) == from;\n\t\t\n\t\t// Bug in HashMap https://github.com/dfinity/motoko-base/pull/253/files\n\t\t// this will throw unless you patch your file\n\t\t_removeApprove(tokenId);\n\t\t\n\t\t_decrementBalance(from);\n\t\t_incrementBalance(to);\n\t\towners.put(tokenId, to);\n\t};\n\t\n\tprivate func _incrementBalance(address : Principal) {\n\t\tswitch (balances.get(address)) {\n\t\t\tcase (?v) {\n\t\t\t\tbalances.put(address, v + 1);\n\t\t\t};\n\t\t\tcase null {\n\t\t\t\tbalances.put(address, 1);\n\t\t\t}\n\t\t}\n\t};\n\t\n\tprivate func _decrementBalance(address : Principal) {\n\t\tswitch (balances.get(address)) {\n\t\t\tcase (?v) {\n\t\t\t\tbalances.put(address, v - 1);\n\t\t\t};\n\t\t\tcase null {\n\t\t\t\tbalances.put(address, 0);\n\t\t\t}\n\t\t}\n\t};\n\t\n\tprivate func _mint(to : Principal, tokenId : Nat, uri : Text) : () {\n\t\tassert not _exists(tokenId);\n\t\t\n\t\t_incrementBalance(to);\n\t\towners.put(tokenId, to);\n\t\ttokenURIs.put(tokenId,uri)\n\t};\n\t\n\tprivate func _burn(tokenId : Nat) {\n\t\tlet owner = _unwrap(_ownerOf(tokenId));\n\t\t\n\t\t_removeApprove(tokenId);\n\t\t_decrementBalance(owner);\n\t\t\n\t\tignore owners.remove(tokenId);\n\t};\n\t\n\tsystem func preupgrade() {\n\t\ttokenURIEntries := Iter.toArray(tokenURIs.entries());\n\t\townersEntries := Iter.toArray(owners.entries());\n\t\tbalancesEntries := Iter.toArray(balances.entries());\n\t\ttokenApprovalsEntries := Iter.toArray(tokenApprovals.entries());\n\t\toperatorApprovalsEntries := Iter.toArray(operatorApprovals.entries());\n\t\t\n\t};\n\t\n\tsystem func postupgrade() {\n\t\ttokenURIEntries := [];\n\t\townersEntries := [];\n\t\tbalancesEntries := [];\n\t\ttokenApprovalsEntries := [];\n\t\toperatorApprovalsEntries := [];\n\t};\n\t\n\tpublic shared(doIOwn__msg) func doIOwn(tokenId : Nat) : async Bool {\n\t\tlet caller = doIOwn__msg.caller; // First input\n\t\t_ownerOf(tokenId) == ?caller;\n\t};\n}","nodes":{"945":{"id":945,"data":{"expression":"// Adapted from: https://github.com/SuddenlyHazel/DIP721/blob/main/src/DIP721/DIP721.mo\r\n\r\nprivate type TokenAddress = Principal;\r\nprivate type TokenId = Nat;\r\n\r\nprivate stable var tokenPk : Nat = 0;\r\n\r\nprivate stable var tokenURIEntries : [(TokenId, Text)] = [];\r\nprivate stable var ownersEntries : [(TokenId, Principal)] = [];\r\nprivate stable var balancesEntries : [(Principal, Nat)] = [];\r\nprivate stable var tokenApprovalsEntries : [(TokenId, Principal)] = [];\r\nprivate stable var operatorApprovalsEntries : [(Principal, [Principal])] = [];\r\n\r\nprivate let tokenURIs : HashMap.HashMap<TokenId, Text> = HashMap.fromIter<TokenId, Text>(tokenURIEntries.vals(), 10, Nat.equal, Hash.hash);\r\nprivate let owners : HashMap.HashMap<TokenId, Principal> = HashMap.fromIter<TokenId, Principal>(ownersEntries.vals(), 10, Nat.equal, Hash.hash);\r\nprivate let balances : HashMap.HashMap<Principal, Nat> = HashMap.fromIter<Principal, Nat>(balancesEntries.vals(), 10, Principal.equal, Principal.hash);\r\nprivate let tokenApprovals : HashMap.HashMap<TokenId, Principal> = HashMap.fromIter<TokenId, Principal>(tokenApprovalsEntries.vals(), 10, Nat.equal, Hash.hash);\r\nprivate let operatorApprovals : HashMap.HashMap<Principal, [Principal]> = HashMap.fromIter<Principal, [Principal]>(operatorApprovalsEntries.vals(), 10, Principal.equal, Principal.hash);\r\n\r\nprivate func _unwrap<T>(x : ?T) : T {\r\n    switch x {\r\n        case null { P.unreachable() };\r\n        case (?x_) { x_ };\r\n    }\r\n};\r\n\r\npublic shared query func balanceOf(p : Principal) : async ?Nat {\r\n    return balances.get(p);\r\n};\r\n\r\npublic shared query func ownerOf(tokenId : TokenId) : async ?Principal {\r\n    return _ownerOf(tokenId);\r\n};\r\n\r\npublic shared query func tokenURI(tokenId : TokenId) : async ?Text {\r\n    return _tokenURI(tokenId);\r\n};\r\n\r\npublic shared query func name() : async Text {\r\n    return _name;\r\n};\r\n\r\npublic shared query func symbol() : async Text {\r\n    return _symbol;\r\n};\r\n\r\npublic shared func isApprovedForAll(owner : Principal, opperator : Principal) : async Bool {\r\n    return _isApprovedForAll(owner, opperator);\r\n};\r\n\r\npublic shared(msg) func approve(to : Principal, tokenId : TokenId) : async () {\r\n    switch(_ownerOf(tokenId)) {\r\n        case (?owner) {\r\n                assert to != owner;\r\n                assert msg.caller == owner or _isApprovedForAll(owner, msg.caller);\r\n                _approve(to, tokenId);\r\n        };\r\n        case (null) {\r\n            throw Error.reject(\"No owner for token\")\r\n        };\r\n    }\r\n};\r\n\r\npublic shared func getApproved(tokenId : Nat) : async Principal {\r\n    switch(_getApproved(tokenId)) {\r\n        case (?v) { return v };\r\n        case null { throw Error.reject(\"None approved\") }\r\n    }\r\n};\r\n\r\npublic shared(msg) func setApprovalForAll(op : Principal, isApproved : Bool) : () {\r\n    assert msg.caller != op;\r\n\r\n    switch (isApproved) {\r\n        case true {\r\n            switch (operatorApprovals.get(msg.caller)) {\r\n                case (?opList) {\r\n                    var array = Array.filter<Principal>(opList,func (p) { p != op });\r\n                    array := Array.append<Principal>(array, [op]);\r\n                    operatorApprovals.put(msg.caller, array);\r\n                };\r\n                case null {\r\n                    operatorApprovals.put(msg.caller, [op]);\r\n                };\r\n            };\r\n        };\r\n        case false {\r\n            switch (operatorApprovals.get(msg.caller)) {\r\n                case (?opList) {\r\n                    let array = Array.filter<Principal>(opList, func(p) { p != op });\r\n                    operatorApprovals.put(msg.caller, array);\r\n                };\r\n                case null {\r\n                    operatorApprovals.put(msg.caller, []);\r\n                };\r\n            };\r\n        };\r\n    };\r\n    \r\n};\r\n\r\npublic shared(msg) func transferFrom(from : Principal, to : Principal, tokenId : Nat) : () {\r\n    assert _isApprovedOrOwner(msg.caller, tokenId);\r\n\r\n    _transfer(from, to, tokenId);\r\n};\r\n\r\npublic shared(msg) func mint(uri : Text) : async Nat {\r\n    tokenPk += 1;\r\n    _mint(msg.caller, tokenPk, uri);\r\n    return tokenPk;\r\n};\r\n\r\n\r\n// Internal\r\n\r\nprivate func _ownerOf(tokenId : TokenId) : ?Principal {\r\n    return owners.get(tokenId);\r\n};\r\n\r\nprivate func _tokenURI(tokenId : TokenId) : ?Text {\r\n    return tokenURIs.get(tokenId);\r\n};\r\n\r\nprivate func _isApprovedForAll(owner : Principal, opperator : Principal) : Bool {\r\n    switch (operatorApprovals.get(owner)) {\r\n        case(?whiteList) {\r\n            for (allow in whiteList.vals()) {\r\n                if (allow == opperator) {\r\n                    return true;\r\n                };\r\n            };\r\n        };\r\n        case null {return false;};\r\n    };\r\n    return false;\r\n};\r\n\r\nprivate func _approve(to : Principal, tokenId : Nat) : () {\r\n    tokenApprovals.put(tokenId, to);\r\n};\r\n\r\nprivate func _removeApprove(tokenId : Nat) : () {\r\n    ignore tokenApprovals.remove(tokenId);\r\n};\r\n\r\nprivate func _exists(tokenId : Nat) : Bool {\r\n    return Option.isSome(owners.get(tokenId));\r\n};\r\n\r\nprivate func _getApproved(tokenId : Nat) : ?Principal {\r\n    assert _exists(tokenId) == true;\r\n    switch(tokenApprovals.get(tokenId)) {\r\n        case (?v) { return ?v };\r\n        case null {\r\n            return null;\r\n        };\r\n    }\r\n};\r\n\r\nprivate func _hasApprovedAndSame(tokenId : Nat, spender : Principal) : Bool {\r\n    switch(_getApproved(tokenId)) {\r\n        case (?v) {\r\n            return v == spender;\r\n        };\r\n        case null { return false }\r\n    }\r\n};\r\n\r\nprivate func _isApprovedOrOwner(spender : Principal, tokenId : Nat) : Bool {\r\n    assert _exists(tokenId);\r\n    let owner = _unwrap(_ownerOf(tokenId));\r\n    return spender == owner or _hasApprovedAndSame(tokenId, spender) or _isApprovedForAll(owner, spender);\r\n};\r\n\r\nprivate func _transfer(from : Principal, to : Principal, tokenId : Nat) : () {\r\n    assert _exists(tokenId);\r\n    assert _unwrap(_ownerOf(tokenId)) == from;\r\n\r\n    // Bug in HashMap https://github.com/dfinity/motoko-base/pull/253/files\r\n    // this will throw unless you patch your file\r\n    _removeApprove(tokenId);\r\n\r\n    _decrementBalance(from);\r\n    _incrementBalance(to);\r\n    owners.put(tokenId, to);\r\n};\r\n\r\nprivate func _incrementBalance(address : Principal) {\r\n    switch (balances.get(address)) {\r\n        case (?v) {\r\n            balances.put(address, v + 1);\r\n        };\r\n        case null {\r\n            balances.put(address, 1);\r\n        }\r\n    }\r\n};\r\n\r\nprivate func _decrementBalance(address : Principal) {\r\n    switch (balances.get(address)) {\r\n        case (?v) {\r\n            balances.put(address, v - 1);\r\n        };\r\n        case null {\r\n            balances.put(address, 0);\r\n        }\r\n    }\r\n};\r\n\r\nprivate func _mint(to : Principal, tokenId : Nat, uri : Text) : () {\r\n    assert not _exists(tokenId);\r\n\r\n    _incrementBalance(to);\r\n    owners.put(tokenId, to);\r\n    tokenURIs.put(tokenId,uri)\r\n};\r\n\r\nprivate func _burn(tokenId : Nat) {\r\n    let owner = _unwrap(_ownerOf(tokenId));\r\n\r\n    _removeApprove(tokenId);\r\n    _decrementBalance(owner);\r\n\r\n    ignore owners.remove(tokenId);\r\n};\r\n\r\nsystem func preupgrade() {\r\n    tokenURIEntries := Iter.toArray(tokenURIs.entries());\r\n    ownersEntries := Iter.toArray(owners.entries());\r\n    balancesEntries := Iter.toArray(balances.entries());\r\n    tokenApprovalsEntries := Iter.toArray(tokenApprovals.entries());\r\n    operatorApprovalsEntries := Iter.toArray(operatorApprovals.entries());\r\n    \r\n};\r\n\r\nsystem func postupgrade() {\r\n    tokenURIEntries := [];\r\n    ownersEntries := [];\r\n    balancesEntries := [];\r\n    tokenApprovalsEntries := [];\r\n    operatorApprovalsEntries := [];\r\n};"},"outputs":{},"position":[-448,-224],"name":"CodeMember"},"946":{"id":946,"data":{"name":"doIOwn","editor:advanced":true,"query":false},"outputs":{"params":{"connections":[{"node":948,"input":"param","data":{}}]},"body":{"connections":[{"node":947,"input":"before","data":{}}]},"caller":{"connections":[{"node":947,"input":"inputs","data":{}}]},"function":{"connections":[]}},"position":[192,-544],"name":"Function"},"947":{"id":947,"data":{"type":{"name":"Bool","generics":[]},"expression":"let caller = {0}; // First input\r\n_ownerOf(tokenId) == ?caller"},"outputs":{"after":{"connections":[]}},"position":[640,-544],"name":"CodeStatement"},"948":{"id":948,"data":{"name":"tokenId","type":{"name":"Nat","generics":[]}},"outputs":{"value":{"connections":[]}},"position":[416,-352],"name":"Parameter"},"1869":{"id":1869,"data":{"expression":"import Error \"mo:base/Error\";\r\nimport Hash \"mo:base/Hash\";\r\nimport HashMap \"mo:base/HashMap\";\r\nimport Nat \"mo:base/Nat\";\r\nimport Option \"mo:base/Option\";\r\nimport Principal \"mo:base/Principal\";\r\nimport Array \"mo:base/Array\";\r\nimport Iter \"mo:base/Iter\";\r\nimport P \"mo:base/Prelude\";"},"outputs":{"result":{"connections":[]}},"position":[-448,-544],"name":"CodeImport"},"1870":{"id":1870,"data":{"widthPixels":418,"text":"DIP721 imports"},"outputs":{},"position":[-448,-592],"name":"Comment"},"1871":{"id":1871,"data":{"widthPixels":419,"text":"DIP721 types, states, and functions"},"outputs":{},"position":[-448,-272],"name":"Comment"},"1872":{"id":1872,"data":{"name":"_name","type":{"name":"Text","generics":[]}},"outputs":{"value":{"connections":[]}},"position":[-448,-800],"name":"MainParameter"},"1873":{"id":1873,"data":{"name":"_symbol","type":{"name":"Text","generics":[]}},"outputs":{"value":{"connections":[]}},"position":[-192,-800],"name":"MainParameter"},"1874":{"id":1874,"data":{"widthPixels":865,"text":"A custom function extending DIP721"},"outputs":{},"position":[192,-592],"name":"Comment"},"1875":{"id":1875,"data":{"widthPixels":419,"text":"DIP721 actor configuration"},"outputs":{},"position":[-448,-848],"name":"Comment"},"1876":{"id":1876,"data":{"widthPixels":494,"heightPixels":925},"outputs":{},"position":[-480,-880],"name":"CommentRegion"},"1877":{"id":1877,"data":{"widthPixels":482,"text":"DIP721: the standard for a Non-Fungible Token (NFT)."},"outputs":{},"position":[-480,-928],"name":"Comment"}}}