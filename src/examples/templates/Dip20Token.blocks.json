{"version":"blocks-webapp@0.2.0","name":"DIP20 Token","description":"A standard fungible token (coin).","readme":"","language":"motoko","output":"import HashMap \"mo:base/HashMap\";\nimport Principal \"mo:base/Principal\";\nimport Time \"mo:base/Time\";\nimport Iter \"mo:base/Iter\";\nimport Array \"mo:base/Array\";\nimport Option \"mo:base/Option\";\nimport Order \"mo:base/Order\";\nimport Nat \"mo:base/Nat\";\nimport Result \"mo:base/Result\";\nimport ExperimentalCycles \"mo:base/ExperimentalCycles\";\nimport P \"mo:base/Prelude\";\n\nactor Dip20Token {\n\tpublic shared query (doIHaveTokens__msg) func doIHaveTokens(minimum : Nat) : async Bool {\n\t\tlet caller = doIHaveTokens__msg.caller; // First input\n\t\t_balanceOf(caller) >= minimum;\n\t};\n\t\n\tstable var logo_ : Text = \"https://via.placeholder.com/500\";\n\t\n\tstable var decimals_ : Nat8 = 2;\n\t\n\tstable var name_ : Text = \"ExampleCoin\";\n\t\n\tstable var totalSupply_ : Nat = 10000000000;\n\t\n\tstable var symbol_ : Text = \"EXC\";\n\t\n\tstable var fee_ : Nat = 1000;\n\t\n\tstable var owner_ : Principal = Principal.fromText(\"2vxsx-fae\");\n\t\n\t// Adapted from: https://github.com/Psychedelic/DIP20/blob/main/motoko/src/token.mo\n\t\n\tprivate type Operation = {\n\t\t#mint;\n\t\t#burn;\n\t\t#transfer;\n\t\t#transferFrom;\n\t\t#approve;\n\t};\n\tprivate type TransactionStatus = {\n\t\t#succeeded;\n\t\t#inprogress;\n\t\t#failed;\n\t};\n\t/// Update call operation record fields\n\tprivate type TxRecord = {\n\t\tcaller: ?Principal;\n\t\top: Operation;\n\t\tindex: Nat;\n\t\tfrom: Principal;\n\t\tto: Principal;\n\t\tamount: Nat;\n\t\tfee: Nat;\n\t\ttimestamp: Time.Time;\n\t\tstatus: TransactionStatus;\n\t};\n\t\n\ttype Metadata = {\n\t\tlogo : Text;\n\t\tname : Text;\n\t\tsymbol : Text;\n\t\tdecimals : Nat8;\n\t\ttotalSupply : Nat;\n\t\towner : Principal;\n\t\tfee : Nat;\n\t};\n\t// returns tx index or error msg\n\tpublic type TxReceipt = {\n\t\t#Ok: Nat;\n\t\t#Err: {\n\t\t\t#InsufficientAllowance;\n\t\t\t#InsufficientBalance;\n\t\t\t#ErrorOperationStyle;\n\t\t\t#Unauthorized;\n\t\t\t#LedgerTrap;\n\t\t\t#ErrorTo;\n\t\t\t#Other;\n\t\t\t#BlockUsed;\n\t\t\t#AmountTooSmall;\n\t\t};\n\t};\n\t\n\tprivate stable var blackhole : Principal = Principal.fromText(\"aaaaa-aa\");\n\tprivate stable var feeTo : Principal = owner_;\n\tprivate stable var fee : Nat = fee_;\n\tprivate stable var balanceEntries : [(Principal, Nat)] = [];\n\tprivate stable var allowanceEntries : [(Principal, [(Principal, Nat)])] = [];\n\tprivate var balances = HashMap.HashMap<Principal, Nat>(1, Principal.equal, Principal.hash);\n\tprivate var allowances = HashMap.HashMap<Principal, HashMap.HashMap<Principal, Nat>>(1, Principal.equal, Principal.hash);\n\tbalances.put(owner_, totalSupply_);\n\tprivate stable let genesis : TxRecord = {\n\t\tcaller = ?owner_;\n\t\top = #mint;\n\t\tindex = 0;\n\t\tfrom = blackhole;\n\t\tto = owner_;\n\t\tamount = totalSupply_;\n\t\tfee = 0;\n\t\ttimestamp = Time.now();\n\t\tstatus = #succeeded;\n\t};\n\tprivate stable var ops : [TxRecord] = [genesis];\n\t\n\tprivate func _unwrap<T>(x : ?T) : T {\n\t\tswitch x {\n\t\t\tcase null { P.unreachable() };\n\t\t\tcase (?x_) { x_ };\n\t\t}\n\t};\n\t\n\tprivate func addRecord(\n\tcaller: ?Principal, op: Operation, from: Principal, to: Principal, amount: Nat,\n\tfee: Nat, timestamp: Time.Time, status: TransactionStatus\n\t): Nat {\n\t\tlet index = ops.size();\n\t\tlet o : TxRecord = {\n\t\t\tcaller = caller;\n\t\t\top = op;\n\t\t\tindex = index;\n\t\t\tfrom = from;\n\t\t\tto = to;\n\t\t\tamount = amount;\n\t\t\tfee = fee;\n\t\t\ttimestamp = timestamp;\n\t\t\tstatus = status;\n\t\t};\n\t\tops := Array.append(ops, [o]);\n\t\treturn index;\n\t};\n\t\n\tprivate func _chargeFee(from: Principal, fee: Nat) {\n\t\tif(fee > 0) {\n\t\t\t_transfer(from, feeTo, fee);\n\t\t};\n\t};\n\t\n\tprivate func _transfer(from: Principal, to: Principal, value: Nat) {\n\t\tlet from_balance = _balanceOf(from);\n\t\tlet from_balance_new : Nat = from_balance - value;\n\t\tif (from_balance_new != 0) { balances.put(from, from_balance_new); }\n\t\telse { balances.delete(from); };\n\t\t\n\t\tlet to_balance = _balanceOf(to);\n\t\tlet to_balance_new : Nat = to_balance + value;\n\t\tif (to_balance_new != 0) { balances.put(to, to_balance_new); };\n\t};\n\t\n\tprivate func _balanceOf(who: Principal) : Nat {\n\t\tswitch (balances.get(who)) {\n\t\t\tcase (?balance) { return balance; };\n\t\t\tcase (_) { return 0; };\n\t\t}\n\t};\n\t\n\tprivate func _allowance(owner: Principal, spender: Principal) : Nat {\n\t\tswitch(allowances.get(owner)) {\n\t\t\tcase (?allowance_owner) {\n\t\t\t\tswitch(allowance_owner.get(spender)) {\n\t\t\t\t\tcase (?allowance) { return allowance; };\n\t\t\t\t\tcase (_) { return 0; };\n\t\t\t\t}\n\t\t\t};\n\t\t\tcase (_) { return 0; };\n\t\t}\n\t};\n\t\n\t/*\n\t*   Core interfaces:\n\t*       update calls:\n\t*           transfer/transferFrom/approve\n\t*       query calls:\n\t*           logo/name/symbol/decimal/totalSupply/balanceOf/allowance/getMetadata\n\t*           historySize/getTransaction/getTransactions\n\t*/\n\t\n\t/// Transfers value amount of tokens to Principal to.\n\tpublic shared(msg) func transfer(to: Principal, value: Nat) : async TxReceipt {\n\t\tif (_balanceOf(msg.caller) < value + fee) { return #Err(#InsufficientBalance); };\n\t\t_chargeFee(msg.caller, fee);\n\t\t_transfer(msg.caller, to, value);\n\t\tlet txid = addRecord(null, #transfer, msg.caller, to, value, fee, Time.now(), #succeeded);\n\t\treturn #Ok(txid);\n\t};\n\t\n\t/// Transfers value amount of tokens from Principal from to Principal to.\n\tpublic shared(msg) func transferFrom(from: Principal, to: Principal, value: Nat) : async TxReceipt {\n\t\tif (_balanceOf(from) < value + fee) { return #Err(#InsufficientBalance); };\n\t\tlet allowed : Nat = _allowance(from, msg.caller);\n\t\tif (allowed < value + fee) { return #Err(#InsufficientAllowance); };\n\t\t_chargeFee(from, fee);\n\t\t_transfer(from, to, value);\n\t\tlet allowed_new : Nat = allowed - value - fee;\n\t\tif (allowed_new != 0) {\n\t\t\tlet allowance_from = _unwrap(allowances.get(from));\n\t\t\tallowance_from.put(msg.caller, allowed_new);\n\t\t\tallowances.put(from, allowance_from);\n\t\t} else {\n\t\t\tif (allowed != 0) {\n\t\t\t\tlet allowance_from = _unwrap(allowances.get(from));\n\t\t\t\tallowance_from.delete(msg.caller);\n\t\t\t\tif (allowance_from.size() == 0) { allowances.delete(from); }\n\t\t\t\telse { allowances.put(from, allowance_from); };\n\t\t\t};\n\t\t};\n\t\tlet txid = addRecord(?msg.caller, #transferFrom, from, to, value, fee, Time.now(), #succeeded);\n\t\treturn #Ok(txid);\n\t};\n\t\n\t/// Allows spender to withdraw from your account multiple times, up to the value amount.\n\t/// If this function is called again it overwrites the current allowance with value.\n\tpublic shared(msg) func approve(spender: Principal, value: Nat) : async TxReceipt {\n\t\tif(_balanceOf(msg.caller) < fee) { return #Err(#InsufficientBalance); };\n\t\t_chargeFee(msg.caller, fee);\n\t\tlet v = value + fee;\n\t\tif (value == 0 and Option.isSome(allowances.get(msg.caller))) {\n\t\t\tlet allowance_caller = _unwrap(allowances.get(msg.caller));\n\t\t\tallowance_caller.delete(spender);\n\t\t\tif (allowance_caller.size() == 0) { allowances.delete(msg.caller); }\n\t\t\telse { allowances.put(msg.caller, allowance_caller); };\n\t\t} else if (value != 0 and Option.isNull(allowances.get(msg.caller))) {\n\t\t\tvar temp = HashMap.HashMap<Principal, Nat>(1, Principal.equal, Principal.hash);\n\t\t\ttemp.put(spender, v);\n\t\t\tallowances.put(msg.caller, temp);\n\t\t} else if (value != 0 and Option.isSome(allowances.get(msg.caller))) {\n\t\t\tlet allowance_caller = _unwrap(allowances.get(msg.caller));\n\t\t\tallowance_caller.put(spender, v);\n\t\t\tallowances.put(msg.caller, allowance_caller);\n\t\t};\n\t\tlet txid = addRecord(null, #approve, msg.caller, spender, v, fee, Time.now(), #succeeded);\n\t\treturn #Ok(txid);\n\t};\n\t\n\tpublic shared(msg) func mint(to: Principal, amount: Nat): async TxReceipt {\n\t\tif(msg.caller != owner_) {\n\t\t\treturn #Err(#Unauthorized);\n\t\t};\n\t\tlet to_balance = _balanceOf(to);\n\t\ttotalSupply_ += amount;\n\t\tbalances.put(to, to_balance + amount);\n\t\tlet txid = addRecord(?msg.caller, #mint, blackhole, to, amount, 0, Time.now(), #succeeded);\n\t\treturn #Ok(txid);\n\t};\n\t\n\tpublic shared(msg) func burn(amount: Nat): async TxReceipt {\n\t\tlet from_balance = _balanceOf(msg.caller);\n\t\tif(from_balance < amount) {\n\t\t\treturn #Err(#InsufficientBalance);\n\t\t};\n\t\ttotalSupply_ -= amount;\n\t\tbalances.put(msg.caller, from_balance - amount);\n\t\tlet txid = addRecord(?msg.caller, #burn, msg.caller, blackhole, amount, 0, Time.now(), #succeeded);\n\t\treturn #Ok(txid);\n\t};\n\t\n\tpublic query func logo() : async Text {\n\t\treturn logo_;\n\t};\n\t\n\tpublic query func name() : async Text {\n\t\treturn name_;\n\t};\n\t\n\tpublic query func symbol() : async Text {\n\t\treturn symbol_;\n\t};\n\t\n\tpublic query func decimals() : async Nat8 {\n\t\treturn decimals_;\n\t};\n\t\n\tpublic query func totalSupply() : async Nat {\n\t\treturn totalSupply_;\n\t};\n\t\n\tpublic query func getTokenFee() : async Nat {\n\t\treturn fee;\n\t};\n\t\n\tpublic query func balanceOf(who: Principal) : async Nat {\n\t\treturn _balanceOf(who);\n\t};\n\t\n\tpublic query func allowance(owner: Principal, spender: Principal) : async Nat {\n\t\treturn _allowance(owner, spender);\n\t};\n\t\n\tpublic query func getMetadata() : async Metadata {\n\t\treturn {\n\t\t\tlogo = logo_;\n\t\t\tname = name_;\n\t\t\tsymbol = symbol_;\n\t\t\tdecimals = decimals_;\n\t\t\ttotalSupply = totalSupply_;\n\t\t\towner = owner_;\n\t\t\tfee = fee;\n\t\t};\n\t};\n\t\n\t/// Get transaction history size\n\tpublic query func historySize() : async Nat {\n\t\treturn ops.size();\n\t};\n\t\n\t/// Get transaction by index.\n\tpublic query func getTransaction(index: Nat) : async TxRecord {\n\t\treturn ops[index];\n\t};\n\t\n\t/// Get history\n\tpublic query func getTransactions(start: Nat, limit: Nat) : async [TxRecord] {\n\t\tvar ret: [TxRecord] = [];\n\t\tvar i = start;\n\t\twhile(i < start + limit and i < ops.size()) {\n\t\t\tret := Array.append(ret, [ops[i]]);\n\t\t\ti += 1;\n\t\t};\n\t\treturn ret;\n\t};\n\t\n\t/*\n\t*   Optional interfaces:\n\t*       setName/setLogo/setFee/setFeeTo/setOwner\n\t*       getUserTransactionsAmount/getUserTransactions\n\t*       getTokenInfo/getHolders/getUserApprovals\n\t*/\n\tpublic shared(msg) func setName(name: Text) {\n\t\tassert(msg.caller == owner_);\n\t\tname_ := name;\n\t};\n\t\n\tpublic shared(msg) func setLogo(logo: Text) {\n\t\tassert(msg.caller == owner_);\n\t\tlogo_ := logo;\n\t};\n\t\n\tpublic shared(msg) func setFeeTo(to: Principal) {\n\t\tassert(msg.caller == owner_);\n\t\tfeeTo := to;\n\t};\n\t\n\tpublic shared(msg) func setFee(_fee: Nat) {\n\t\tassert(msg.caller == owner_);\n\t\tfee := _fee;\n\t};\n\t\n\tpublic shared(msg) func setOwner(_owner: Principal) {\n\t\tassert(msg.caller == owner_);\n\t\towner_ := _owner;\n\t};\n\t\n\tpublic query func getUserTransactionAmount(a: Principal) : async Nat {\n\t\tvar res: Nat = 0;\n\t\tfor (i in ops.vals()) {\n\t\t\tif (i.caller == ?a or i.from == a or i.to == a) {\n\t\t\t\tres += 1;\n\t\t\t};\n\t\t};\n\t\treturn res;\n\t};\n\t\n\tpublic query func getUserTransactions(a: Principal, start: Nat, limit: Nat) : async [TxRecord] {\n\t\tvar res: [TxRecord] = [];\n\t\tvar index: Nat = 0;\n\t\tfor (i in ops.vals()) {\n\t\t\tif (i.caller == ?a or i.from == a or i.to == a) {\n\t\t\t\tif(index >= start and index < start + limit) {\n\t\t\t\t\tres := Array.append<TxRecord>(res, [i]);\n\t\t\t\t};\n\t\t\t\tindex += 1;\n\t\t\t};\n\t\t};\n\t\treturn res;\n\t};\n\t\n\tpublic type TokenInfo = {\n\t\tmetadata: Metadata;\n\t\tfeeTo: Principal;\n\t\t// status info\n\t\thistorySize: Nat;\n\t\tdeployTime: Time.Time;\n\t\tholderNumber: Nat;\n\t\tcycles: Nat;\n\t};\n\tpublic query func getTokenInfo(): async TokenInfo {\n\t\t{\n\t\t\tmetadata = {\n\t\t\t\tlogo = logo_;\n\t\t\t\tname = name_;\n\t\t\t\tsymbol = symbol_;\n\t\t\t\tdecimals = decimals_;\n\t\t\t\ttotalSupply = totalSupply_;\n\t\t\t\towner = owner_;\n\t\t\t\tfee = fee;\n\t\t\t};\n\t\t\tfeeTo = feeTo;\n\t\t\thistorySize = ops.size();\n\t\t\tdeployTime = genesis.timestamp;\n\t\t\tholderNumber = balances.size();\n\t\t\tcycles = ExperimentalCycles.balance();\n\t\t}\n\t};\n\t\n\tpublic query func getHolders(start: Nat, limit: Nat) : async [(Principal, Nat)] {\n\t\tlet temp =  Iter.toArray(balances.entries());\n\t\tfunc order (a: (Principal, Nat), b: (Principal, Nat)) : Order.Order {\n\t\t\treturn Nat.compare(b.1, a.1);\n\t\t};\n\t\tlet sorted = Array.sort(temp, order);\n\t\tlet limit_: Nat = if(start + limit > temp.size()) {\n\t\t\ttemp.size() - start\n\t\t} else {\n\t\t\tlimit\n\t\t};\n\t\tlet res = Array.init<(Principal, Nat)>(limit_, (owner_, 0));\n\t\tfor (i in Iter.range(0, limit_ - 1)) {\n\t\t\tres[i] := sorted[i+start];\n\t\t};\n\t\treturn Array.freeze(res);\n\t};\n\t\n\tpublic query func getAllowanceSize() : async Nat {\n\t\tvar size : Nat = 0;\n\t\tfor ((k, v) in allowances.entries()) {\n\t\t\tsize += v.size();\n\t\t};\n\t\treturn size;\n\t};\n\t\n\tpublic query func getUserApprovals(who : Principal) : async [(Principal, Nat)] {\n\t\tswitch (allowances.get(who)) {\n\t\t\tcase (?allowance_who) {\n\t\t\t\treturn Iter.toArray(allowance_who.entries());\n\t\t\t};\n\t\t\tcase (_) {\n\t\t\t\treturn [];\n\t\t\t};\n\t\t}\n\t};\n\t\n\t/*\n\t* upgrade functions\n\t*/\n\tsystem func preupgrade() {\n\t\tbalanceEntries := Iter.toArray(balances.entries());\n\t\tvar size : Nat = allowances.size();\n\t\tvar temp : [var (Principal, [(Principal, Nat)])] = Array.init<(Principal, [(Principal, Nat)])>(size, (owner_, []));\n\t\tsize := 0;\n\t\tfor ((k, v) in allowances.entries()) {\n\t\t\ttemp[size] := (k, Iter.toArray(v.entries()));\n\t\t\tsize += 1;\n\t\t};\n\t\tallowanceEntries := Array.freeze(temp);\n\t};\n\t\n\tsystem func postupgrade() {\n\t\tbalances := HashMap.fromIter<Principal, Nat>(balanceEntries.vals(), 1, Principal.equal, Principal.hash);\n\t\tbalanceEntries := [];\n\t\tfor ((k, v) in allowanceEntries.vals()) {\n\t\t\tlet allowed_temp = HashMap.fromIter<Principal, Nat>(v.vals(), 1, Principal.equal, Principal.hash);\n\t\t\tallowances.put(k, allowed_temp);\n\t\t};\n\t\tallowanceEntries := [];\n\t};\n}","nodes":{"945":{"id":945,"data":{"expression":"// Adapted from: https://github.com/Psychedelic/DIP20/blob/main/motoko/src/token.mo\r\n\r\nprivate type Operation = {\r\n    #mint;\r\n    #burn;\r\n    #transfer;\r\n    #transferFrom;\r\n    #approve;\r\n};\r\nprivate type TransactionStatus = {\r\n    #succeeded;\r\n    #inprogress;\r\n    #failed;\r\n};\r\n/// Update call operation record fields\r\nprivate type TxRecord = {\r\n    caller: ?Principal;\r\n    op: Operation;\r\n    index: Nat;\r\n    from: Principal;\r\n    to: Principal;\r\n    amount: Nat;\r\n    fee: Nat;\r\n    timestamp: Time.Time;\r\n    status: TransactionStatus;\r\n};\r\n\r\ntype Metadata = {\r\n    logo : Text;\r\n    name : Text;\r\n    symbol : Text;\r\n    decimals : Nat8;\r\n    totalSupply : Nat;\r\n    owner : Principal;\r\n    fee : Nat;\r\n};\r\n// returns tx index or error msg\r\npublic type TxReceipt = {\r\n    #Ok: Nat;\r\n    #Err: {\r\n        #InsufficientAllowance;\r\n        #InsufficientBalance;\r\n        #ErrorOperationStyle;\r\n        #Unauthorized;\r\n        #LedgerTrap;\r\n        #ErrorTo;\r\n        #Other;\r\n        #BlockUsed;\r\n        #AmountTooSmall;\r\n    };\r\n};\r\n\r\nprivate stable var blackhole : Principal = Principal.fromText(\"aaaaa-aa\");\r\nprivate stable var feeTo : Principal = owner_;\r\nprivate stable var fee : Nat = fee_;\r\nprivate stable var balanceEntries : [(Principal, Nat)] = [];\r\nprivate stable var allowanceEntries : [(Principal, [(Principal, Nat)])] = [];\r\nprivate var balances = HashMap.HashMap<Principal, Nat>(1, Principal.equal, Principal.hash);\r\nprivate var allowances = HashMap.HashMap<Principal, HashMap.HashMap<Principal, Nat>>(1, Principal.equal, Principal.hash);\r\nbalances.put(owner_, totalSupply_);\r\nprivate stable let genesis : TxRecord = {\r\n    caller = ?owner_;\r\n    op = #mint;\r\n    index = 0;\r\n    from = blackhole;\r\n    to = owner_;\r\n    amount = totalSupply_;\r\n    fee = 0;\r\n    timestamp = Time.now();\r\n    status = #succeeded;\r\n};\r\nprivate stable var ops : [TxRecord] = [genesis];\r\n\r\nprivate func _unwrap<T>(x : ?T) : T {\r\n    switch x {\r\n        case null { P.unreachable() };\r\n        case (?x_) { x_ };\r\n    }\r\n};\r\n\r\nprivate func addRecord(\r\n    caller: ?Principal, op: Operation, from: Principal, to: Principal, amount: Nat,\r\n    fee: Nat, timestamp: Time.Time, status: TransactionStatus\r\n): Nat {\r\n    let index = ops.size();\r\n    let o : TxRecord = {\r\n        caller = caller;\r\n        op = op;\r\n        index = index;\r\n        from = from;\r\n        to = to;\r\n        amount = amount;\r\n        fee = fee;\r\n        timestamp = timestamp;\r\n        status = status;\r\n    };\r\n    ops := Array.append(ops, [o]);\r\n    return index;\r\n};\r\n\r\nprivate func _chargeFee(from: Principal, fee: Nat) {\r\n    if(fee > 0) {\r\n        _transfer(from, feeTo, fee);\r\n    };\r\n};\r\n\r\nprivate func _transfer(from: Principal, to: Principal, value: Nat) {\r\n    let from_balance = _balanceOf(from);\r\n    let from_balance_new : Nat = from_balance - value;\r\n    if (from_balance_new != 0) { balances.put(from, from_balance_new); }\r\n    else { balances.delete(from); };\r\n\r\n    let to_balance = _balanceOf(to);\r\n    let to_balance_new : Nat = to_balance + value;\r\n    if (to_balance_new != 0) { balances.put(to, to_balance_new); };\r\n};\r\n\r\nprivate func _balanceOf(who: Principal) : Nat {\r\n    switch (balances.get(who)) {\r\n        case (?balance) { return balance; };\r\n        case (_) { return 0; };\r\n    }\r\n};\r\n\r\nprivate func _allowance(owner: Principal, spender: Principal) : Nat {\r\n    switch(allowances.get(owner)) {\r\n        case (?allowance_owner) {\r\n            switch(allowance_owner.get(spender)) {\r\n                case (?allowance) { return allowance; };\r\n                case (_) { return 0; };\r\n            }\r\n        };\r\n        case (_) { return 0; };\r\n    }\r\n};\r\n\r\n/*\r\n*   Core interfaces:\r\n*       update calls:\r\n*           transfer/transferFrom/approve\r\n*       query calls:\r\n*           logo/name/symbol/decimal/totalSupply/balanceOf/allowance/getMetadata\r\n*           historySize/getTransaction/getTransactions\r\n*/\r\n\r\n/// Transfers value amount of tokens to Principal to.\r\npublic shared(msg) func transfer(to: Principal, value: Nat) : async TxReceipt {\r\n    if (_balanceOf(msg.caller) < value + fee) { return #Err(#InsufficientBalance); };\r\n    _chargeFee(msg.caller, fee);\r\n    _transfer(msg.caller, to, value);\r\n    let txid = addRecord(null, #transfer, msg.caller, to, value, fee, Time.now(), #succeeded);\r\n    return #Ok(txid);\r\n};\r\n\r\n/// Transfers value amount of tokens from Principal from to Principal to.\r\npublic shared(msg) func transferFrom(from: Principal, to: Principal, value: Nat) : async TxReceipt {\r\n    if (_balanceOf(from) < value + fee) { return #Err(#InsufficientBalance); };\r\n    let allowed : Nat = _allowance(from, msg.caller);\r\n    if (allowed < value + fee) { return #Err(#InsufficientAllowance); };\r\n    _chargeFee(from, fee);\r\n    _transfer(from, to, value);\r\n    let allowed_new : Nat = allowed - value - fee;\r\n    if (allowed_new != 0) {\r\n        let allowance_from = _unwrap(allowances.get(from));\r\n        allowance_from.put(msg.caller, allowed_new);\r\n        allowances.put(from, allowance_from);\r\n    } else {\r\n        if (allowed != 0) {\r\n            let allowance_from = _unwrap(allowances.get(from));\r\n            allowance_from.delete(msg.caller);\r\n            if (allowance_from.size() == 0) { allowances.delete(from); }\r\n            else { allowances.put(from, allowance_from); };\r\n        };\r\n    };\r\n    let txid = addRecord(?msg.caller, #transferFrom, from, to, value, fee, Time.now(), #succeeded);\r\n    return #Ok(txid);\r\n};\r\n\r\n/// Allows spender to withdraw from your account multiple times, up to the value amount.\r\n/// If this function is called again it overwrites the current allowance with value.\r\npublic shared(msg) func approve(spender: Principal, value: Nat) : async TxReceipt {\r\n    if(_balanceOf(msg.caller) < fee) { return #Err(#InsufficientBalance); };\r\n    _chargeFee(msg.caller, fee);\r\n    let v = value + fee;\r\n    if (value == 0 and Option.isSome(allowances.get(msg.caller))) {\r\n        let allowance_caller = _unwrap(allowances.get(msg.caller));\r\n        allowance_caller.delete(spender);\r\n        if (allowance_caller.size() == 0) { allowances.delete(msg.caller); }\r\n        else { allowances.put(msg.caller, allowance_caller); };\r\n    } else if (value != 0 and Option.isNull(allowances.get(msg.caller))) {\r\n        var temp = HashMap.HashMap<Principal, Nat>(1, Principal.equal, Principal.hash);\r\n        temp.put(spender, v);\r\n        allowances.put(msg.caller, temp);\r\n    } else if (value != 0 and Option.isSome(allowances.get(msg.caller))) {\r\n        let allowance_caller = _unwrap(allowances.get(msg.caller));\r\n        allowance_caller.put(spender, v);\r\n        allowances.put(msg.caller, allowance_caller);\r\n    };\r\n    let txid = addRecord(null, #approve, msg.caller, spender, v, fee, Time.now(), #succeeded);\r\n    return #Ok(txid);\r\n};\r\n\r\npublic shared(msg) func mint(to: Principal, amount: Nat): async TxReceipt {\r\n    if(msg.caller != owner_) {\r\n        return #Err(#Unauthorized);\r\n    };\r\n    let to_balance = _balanceOf(to);\r\n    totalSupply_ += amount;\r\n    balances.put(to, to_balance + amount);\r\n    let txid = addRecord(?msg.caller, #mint, blackhole, to, amount, 0, Time.now(), #succeeded);\r\n    return #Ok(txid);\r\n};\r\n\r\npublic shared(msg) func burn(amount: Nat): async TxReceipt {\r\n    let from_balance = _balanceOf(msg.caller);\r\n    if(from_balance < amount) {\r\n        return #Err(#InsufficientBalance);\r\n    };\r\n    totalSupply_ -= amount;\r\n    balances.put(msg.caller, from_balance - amount);\r\n    let txid = addRecord(?msg.caller, #burn, msg.caller, blackhole, amount, 0, Time.now(), #succeeded);\r\n    return #Ok(txid);\r\n};\r\n\r\npublic query func logo() : async Text {\r\n    return logo_;\r\n};\r\n\r\npublic query func name() : async Text {\r\n    return name_;\r\n};\r\n\r\npublic query func symbol() : async Text {\r\n    return symbol_;\r\n};\r\n\r\npublic query func decimals() : async Nat8 {\r\n    return decimals_;\r\n};\r\n\r\npublic query func totalSupply() : async Nat {\r\n    return totalSupply_;\r\n};\r\n\r\npublic query func getTokenFee() : async Nat {\r\n    return fee;\r\n};\r\n\r\npublic query func balanceOf(who: Principal) : async Nat {\r\n    return _balanceOf(who);\r\n};\r\n\r\npublic query func allowance(owner: Principal, spender: Principal) : async Nat {\r\n    return _allowance(owner, spender);\r\n};\r\n\r\npublic query func getMetadata() : async Metadata {\r\n    return {\r\n        logo = logo_;\r\n        name = name_;\r\n        symbol = symbol_;\r\n        decimals = decimals_;\r\n        totalSupply = totalSupply_;\r\n        owner = owner_;\r\n        fee = fee;\r\n    };\r\n};\r\n\r\n/// Get transaction history size\r\npublic query func historySize() : async Nat {\r\n    return ops.size();\r\n};\r\n\r\n/// Get transaction by index.\r\npublic query func getTransaction(index: Nat) : async TxRecord {\r\n    return ops[index];\r\n};\r\n\r\n/// Get history\r\npublic query func getTransactions(start: Nat, limit: Nat) : async [TxRecord] {\r\n    var ret: [TxRecord] = [];\r\n    var i = start;\r\n    while(i < start + limit and i < ops.size()) {\r\n        ret := Array.append(ret, [ops[i]]);\r\n        i += 1;\r\n    };\r\n    return ret;\r\n};\r\n\r\n/*\r\n*   Optional interfaces:\r\n*       setName/setLogo/setFee/setFeeTo/setOwner\r\n*       getUserTransactionsAmount/getUserTransactions\r\n*       getTokenInfo/getHolders/getUserApprovals\r\n*/\r\npublic shared(msg) func setName(name: Text) {\r\n    assert(msg.caller == owner_);\r\n    name_ := name;\r\n};\r\n\r\npublic shared(msg) func setLogo(logo: Text) {\r\n    assert(msg.caller == owner_);\r\n    logo_ := logo;\r\n};\r\n\r\npublic shared(msg) func setFeeTo(to: Principal) {\r\n    assert(msg.caller == owner_);\r\n    feeTo := to;\r\n};\r\n\r\npublic shared(msg) func setFee(_fee: Nat) {\r\n    assert(msg.caller == owner_);\r\n    fee := _fee;\r\n};\r\n\r\npublic shared(msg) func setOwner(_owner: Principal) {\r\n    assert(msg.caller == owner_);\r\n    owner_ := _owner;\r\n};\r\n\r\npublic query func getUserTransactionAmount(a: Principal) : async Nat {\r\n    var res: Nat = 0;\r\n    for (i in ops.vals()) {\r\n        if (i.caller == ?a or i.from == a or i.to == a) {\r\n            res += 1;\r\n        };\r\n    };\r\n    return res;\r\n};\r\n\r\npublic query func getUserTransactions(a: Principal, start: Nat, limit: Nat) : async [TxRecord] {\r\n    var res: [TxRecord] = [];\r\n    var index: Nat = 0;\r\n    for (i in ops.vals()) {\r\n        if (i.caller == ?a or i.from == a or i.to == a) {\r\n            if(index >= start and index < start + limit) {\r\n                res := Array.append<TxRecord>(res, [i]);\r\n            };\r\n            index += 1;\r\n        };\r\n    };\r\n    return res;\r\n};\r\n\r\npublic type TokenInfo = {\r\n    metadata: Metadata;\r\n    feeTo: Principal;\r\n    // status info\r\n    historySize: Nat;\r\n    deployTime: Time.Time;\r\n    holderNumber: Nat;\r\n    cycles: Nat;\r\n};\r\npublic query func getTokenInfo(): async TokenInfo {\r\n    {\r\n        metadata = {\r\n            logo = logo_;\r\n            name = name_;\r\n            symbol = symbol_;\r\n            decimals = decimals_;\r\n            totalSupply = totalSupply_;\r\n            owner = owner_;\r\n            fee = fee;\r\n        };\r\n        feeTo = feeTo;\r\n        historySize = ops.size();\r\n        deployTime = genesis.timestamp;\r\n        holderNumber = balances.size();\r\n        cycles = ExperimentalCycles.balance();\r\n    }\r\n};\r\n\r\npublic query func getHolders(start: Nat, limit: Nat) : async [(Principal, Nat)] {\r\n    let temp =  Iter.toArray(balances.entries());\r\n    func order (a: (Principal, Nat), b: (Principal, Nat)) : Order.Order {\r\n        return Nat.compare(b.1, a.1);\r\n    };\r\n    let sorted = Array.sort(temp, order);\r\n    let limit_: Nat = if(start + limit > temp.size()) {\r\n        temp.size() - start\r\n    } else {\r\n        limit\r\n    };\r\n    let res = Array.init<(Principal, Nat)>(limit_, (owner_, 0));\r\n    for (i in Iter.range(0, limit_ - 1)) {\r\n        res[i] := sorted[i+start];\r\n    };\r\n    return Array.freeze(res);\r\n};\r\n\r\npublic query func getAllowanceSize() : async Nat {\r\n    var size : Nat = 0;\r\n    for ((k, v) in allowances.entries()) {\r\n        size += v.size();\r\n    };\r\n    return size;\r\n};\r\n\r\npublic query func getUserApprovals(who : Principal) : async [(Principal, Nat)] {\r\n    switch (allowances.get(who)) {\r\n        case (?allowance_who) {\r\n            return Iter.toArray(allowance_who.entries());\r\n        };\r\n        case (_) {\r\n            return [];\r\n        };\r\n    }\r\n};\r\n\r\n/*\r\n* upgrade functions\r\n*/\r\nsystem func preupgrade() {\r\n    balanceEntries := Iter.toArray(balances.entries());\r\n    var size : Nat = allowances.size();\r\n    var temp : [var (Principal, [(Principal, Nat)])] = Array.init<(Principal, [(Principal, Nat)])>(size, (owner_, []));\r\n    size := 0;\r\n    for ((k, v) in allowances.entries()) {\r\n        temp[size] := (k, Iter.toArray(v.entries()));\r\n        size += 1;\r\n    };\r\n    allowanceEntries := Array.freeze(temp);\r\n};\r\n\r\nsystem func postupgrade() {\r\n    balances := HashMap.fromIter<Principal, Nat>(balanceEntries.vals(), 1, Principal.equal, Principal.hash);\r\n    balanceEntries := [];\r\n    for ((k, v) in allowanceEntries.vals()) {\r\n        let allowed_temp = HashMap.fromIter<Principal, Nat>(v.vals(), 1, Principal.equal, Principal.hash);\r\n        allowances.put(k, allowed_temp);\r\n    };\r\n    allowanceEntries := [];\r\n};"},"outputs":{},"position":[-416,-400],"name":"CodeMember"},"946":{"id":946,"data":{"name":"doIHaveTokens","editor:advanced":true,"query":true},"outputs":{"params":{"connections":[{"node":1886,"input":"param","data":{}}]},"body":{"connections":[{"node":947,"input":"before","data":{}}]},"caller":{"connections":[{"node":947,"input":"inputs","data":{}}]},"function":{"connections":[]}},"position":[192,-784],"name":"Function"},"947":{"id":947,"data":{"type":{"name":"Bool","generics":[]},"expression":"let caller = {0}; // First input\r\n_balanceOf(caller) >= minimum"},"outputs":{"after":{"connections":[]}},"position":[640,-784],"name":"CodeStatement"},"1869":{"id":1869,"data":{"expression":"import HashMap \"mo:base/HashMap\";\r\nimport Principal \"mo:base/Principal\";\r\nimport Time \"mo:base/Time\";\r\nimport Iter \"mo:base/Iter\";\r\nimport Array \"mo:base/Array\";\r\nimport Option \"mo:base/Option\";\r\nimport Order \"mo:base/Order\";\r\nimport Nat \"mo:base/Nat\";\r\nimport Result \"mo:base/Result\";\r\nimport ExperimentalCycles \"mo:base/ExperimentalCycles\";\r\nimport P \"mo:base/Prelude\";"},"outputs":{"result":{"connections":[]}},"position":[-416,-784],"name":"CodeImport"},"1870":{"id":1870,"data":{"widthPixels":418,"text":"DIP20 imports"},"outputs":{},"position":[-416,-832],"name":"Comment"},"1871":{"id":1871,"data":{"widthPixels":419,"text":"DIP20 types, states, and functions"},"outputs":{},"position":[-416,-448],"name":"Comment"},"1874":{"id":1874,"data":{"widthPixels":865,"text":"A custom function extending DIP20"},"outputs":{},"position":[192,-832],"name":"Comment"},"1875":{"id":1875,"data":{"widthPixels":834,"text":"Token configuration"},"outputs":{},"position":[-1344,-832],"name":"Comment"},"1876":{"id":1876,"data":{"widthPixels":1420,"heightPixels":765},"outputs":{},"position":[-1376,-880],"name":"CommentRegion"},"1877":{"id":1877,"data":{"widthPixels":1409,"text":"DIP20: the Internet Computer standard for a fungible token / coin."},"outputs":{},"position":[-1376,-928],"name":"Comment"},"1886":{"id":1886,"data":{"name":"minimum","type":{"name":"Nat","generics":[]}},"outputs":{"value":{"connections":[]}},"position":[416,-608],"name":"Parameter"},"1926":{"id":1926,"data":{"name":"logo_","editor:advanced":true,"stable":true},"outputs":{"setup":{"connections":[]},"value":{"connections":[]}},"position":[-1344,-768],"name":"State"},"1927":{"id":1927,"data":{"name":"name_","editor:advanced":true,"stable":true},"outputs":{"setup":{"connections":[]},"value":{"connections":[]}},"position":[-1120,-768],"name":"State"},"1929":{"id":1929,"data":{"name":"symbol_","editor:advanced":true,"stable":true},"outputs":{"setup":{"connections":[]},"value":{"connections":[]}},"position":[-896,-768],"name":"State"},"1930":{"id":1930,"data":{"name":"decimals_","editor:advanced":true,"stable":true},"outputs":{"setup":{"connections":[]},"value":{"connections":[]}},"position":[-1344,-448],"name":"State"},"1931":{"id":1931,"data":{"value":"https://via.placeholder.com/500"},"outputs":{"value":{"connections":[{"node":1926,"input":"initialValue","data":{}}]}},"position":[-1344,-576],"name":"LiteralText"},"1932":{"id":1932,"data":{"value":"ExampleCoin"},"outputs":{"value":{"connections":[{"node":1927,"input":"initialValue","data":{}}]}},"position":[-1120,-576],"name":"LiteralText"},"1933":{"id":1933,"data":{"value":"EXC"},"outputs":{"value":{"connections":[{"node":1929,"input":"initialValue","data":{}}]}},"position":[-896,-576],"name":"LiteralText"},"1934":{"id":1934,"data":{"name":"totalSupply_","editor:advanced":true,"stable":true},"outputs":{"setup":{"connections":[]},"value":{"connections":[]}},"position":[-1120,-448],"name":"State"},"1935":{"id":1935,"data":{"value":10000000000},"outputs":{"value":{"connections":[{"node":1934,"input":"initialValue","data":{}}]}},"position":[-1120,-256],"name":"LiteralNat"},"1936":{"id":1936,"data":{"name":"owner_","editor:advanced":true,"stable":true},"outputs":{"setup":{"connections":[]},"value":{"connections":[]}},"position":[-672,-768],"name":"State"},"1937":{"id":1937,"data":{"value":"2vxsx-fae"},"outputs":{"value":{"connections":[{"node":1936,"input":"initialValue","data":{}}]}},"position":[-672,-576],"name":"LiteralPrincipal"},"1938":{"id":1938,"data":{"name":"fee_","editor:advanced":true,"stable":true},"outputs":{"setup":{"connections":[]},"value":{"connections":[]}},"position":[-896,-448],"name":"State"},"1939":{"id":1939,"data":{"value":1000},"outputs":{"value":{"connections":[{"node":1938,"input":"initialValue","data":{}}]}},"position":[-896,-256],"name":"LiteralNat"},"2017":{"id":2017,"data":{"type":{"name":"Nat8","generics":[]},"input":"2"},"outputs":{"value":{"connections":[{"node":1930,"input":"initialValue","data":{}}]}},"position":[-1344,-256],"name":"LiteralNumber"}}}